package com.kyripay.traces.domain.trace;


import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AccessLevel;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.hateoas.Identifiable;

import javax.persistence.*;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;


@Data
@Entity
@Table(name = "TRACES")
public class Trace implements Identifiable<Long>
{
  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE)
  @Column(name = "TRACE_ID", nullable = false, unique = true, updatable = false)
  private Long id;
  //TODO: review business requirements!!! Seems that such PK has no value. Actually, "paymentId" identifies the Trace much better than autogenerated PK.
  //And there seems to be a strict rule: One payment = One Trace. In this case - autogenerated PK not required; "paymentId" will act as PK.

  @Column(name = "PAYMENT_ID", nullable = false, unique = true, updatable = false)
  private long paymentId;

  @Column(name = "CREATION_DATE_TIME")
  @LastModifiedDate //TODO check whether it really works (corresponding HTTP header in the response)
  private LocalDateTime created;

  @Column(name = "UPDATE_DATE_TIME")
  @LastModifiedDate
  private LocalDateTime updated;


  //https://reviewdb.io/questions/1505120348934/how-to-store-map-string-string-using-jpa
  @ElementCollection
  @MapKeyColumn(name = "NAME")
  @Column(name = "VALUE")
  @CollectionTable(name = "TRACE_HEADERS", joinColumns = @JoinColumn(name = "TRACE_ID"))
  @Getter(AccessLevel.NONE)
  @Setter(AccessLevel.NONE)
  @JsonIgnore
  private Map<String, String> headerMap = new HashMap<>();

  @ElementCollection
  @CollectionTable(name = "TRACE_EVENTS", joinColumns = @JoinColumn(name = "TRACE_ID"))
  @JsonIgnore
  @Setter(AccessLevel.NONE)
  private List<Event> events = new ArrayList<>();


  /**
   * Convenience method to represent headers as a list of {@link Header} objects.
   */
  @JsonIgnore
  public List<Header> getHeaders()
  {
    return Collections.unmodifiableList(
        headerMap.entrySet().stream().map(entry -> new Header(entry.getKey(), entry.getValue())).collect(Collectors.toList()));
  }


  public void addHeader(String name, String value)
  {
    Objects.requireNonNull(name, "Header name is NULL");
    Objects.requireNonNull(value, "Header value is NULL");
    headerMap.put(name.toUpperCase(), value);
  }


  public boolean removeHeader(String name)
  {
    Objects.requireNonNull(name, "Header name is NULL");
    if (headerMap.containsKey(name.toUpperCase())) {
      headerMap.remove(name.toUpperCase());
      return true;
    }
    else {
      return false;
    }
  }


  public boolean updateHeader(String name, String newValue)
  {
    for (Map.Entry<String, String> entry : headerMap.entrySet()) {
      if (entry.getKey().equalsIgnoreCase(name)) {
        entry.setValue(newValue);
        return true;
      }
    }
    return false;
  }


  public void addHeader(Header header)
  {
    addHeader(header.getName(), header.getValue());
  }


  public void addEvent(Event event)
  {
    events.add(event);
  }


  public List<Event> getEvents()
  {
    return Collections.unmodifiableList(events);
  }


}
