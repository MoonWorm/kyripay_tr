package com.kyripay.traces.domain.trace;


import com.kyripay.traces.dto.representation.TraceRepresentation;
import com.kyripay.traces.dto.request.TraceCreationRequest;
import lombok.AccessLevel;
import lombok.Data;
import lombok.Setter;
import org.springframework.hateoas.Identifiable;

import javax.persistence.*;
import java.time.LocalDateTime;
import java.util.*;


@Data
@Entity
@Table(name = "TRACES")
public class Trace implements Identifiable<Long>
{

  @Id //It is primary key but it is not autogenerated. Instead, it represents and is equal to "Payment ID" which is provided explicitly via API when creating Trace
  @Column(name = "PAYMENT_ID", nullable = false, unique = true, updatable = false)
  private long paymentId;

  //TODO Use @EnableJpaAuditing, @LastModifiedDate, etc - to manage creation / update timestamps automatically (here and in Event)
  @Column(name = "CREATION_DATE_TIME")
  private LocalDateTime created;

  @Column(name = "UPDATE_DATE_TIME")
  private LocalDateTime updated;


  //https://reviewdb.io/questions/1505120348934/how-to-store-map-string-string-using-jpa
  @ElementCollection
  @MapKeyColumn(name = "NAME")
  @Column(name = "VALUE")
  @CollectionTable(name = "TRACE_HEADERS", joinColumns = @JoinColumn(name = "TRACE_ID"))
  private Map<String, String> headerMap = new HashMap<>();

  @ElementCollection
  @CollectionTable(name = "TRACE_EVENTS", joinColumns = @JoinColumn(name = "TRACE_ID"))
  @Setter(AccessLevel.NONE)
  @OrderBy("created ASC")
  private List<Event> events = new ArrayList<>();


  @Override
  public Long getId()
  {
    return paymentId;
  }


  public boolean putHeader(String name, String value)
  {
    Objects.requireNonNull(name, "Header name is NULL");
    Objects.requireNonNull(value, "Header value is NULL");
    return headerMap.put(name.toUpperCase(), value) == null;
  }


  public boolean removeHeader(String name)
  {
    Objects.requireNonNull(name, "Header name is NULL");
    if (headerMap.containsKey(name.toUpperCase())) {
      headerMap.remove(name.toUpperCase());
      return true;
    }
    else {
      return false;
    }
  }


  public void setHeaders(Map<String, String> headers)
  {
    headerMap = new HashMap<>();
    headers.forEach((key, value) -> headerMap.put(key.toUpperCase(), value));
  }


  public void addEvent(Event event)
  {
    events.add(event);
  }


  public List<Event> getEvents()
  {
    return Collections.unmodifiableList(events);
  }


  public static Trace fromCreationRequest(TraceCreationRequest creationRequest)
  {
    Trace trace = new Trace();
    trace.setPaymentId(creationRequest.getPaymentId());
    trace.setCreated(LocalDateTime.now());
    Optional.ofNullable(creationRequest.getHeaders()).ifPresent(trace::setHeaders);

    return trace;
  }


  public TraceRepresentation toRepresentation()
  {
    return TraceRepresentation.builder()
        .paymentId(paymentId)
        .headers(headerMap)
        .created(created)
        .build();
  }
}
